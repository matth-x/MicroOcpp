{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>MicroOCPP is an OCPP client which runs on microcontrollers and enables EVSEs to participate in OCPP charging networks. As a software library, it can be added to the firmware of the EVSE and will become a new part of it. If the EVSE has already an internet controller, then most likely, no extra hardware is required.</p> <p>Technical introduction</p> <p>Migrating to v1.0</p> <p>Modules</p> <p>Development tools and basic prerequisites</p> <p>Security whitepaper</p> <p>Documentation WIP. See the GitHub Readme or the API description as reference.</p>"},{"location":"benchmarks/","title":"Benchmarks","text":"<p>Microcontrollers have tight hardware constraints which affect how much resources the firmware can demand. It is important to make sure that the available resources are not depleted to allow for robust operation and that there is sufficient flash head room to allow for future software upgrades.</p> <p>In general, microcontrollers have three relevant hardware constraints:</p> <ul> <li>Limited processing speed</li> <li>Limited memory size</li> <li>Limited flash size</li> </ul> <p>For OCPP, the relevant bottlenecks are especially the memory and flash size. The processing speed is no concern, since OCPP is not computationally complex and does not include any extensive planning algorithms on the charger size. A previous benchmark on the ESP-IDF showed that the processing times are in the lower milliseconds range and are probably outweighed by IO times and network round trip times.</p> <p>However, the memory and flash requirements are important figures, because the device model of OCPP has a significant size. The microcontroller needs to keep the model data in the heap memory for the largest part and the firmware which covers the corresponding processing routines needs to have sufficient space on flash.</p> <p>This chapter presents benchmarks of the memory and flash requirements. They should help to determine the required microcontroller capabilities, or to give general insights for taking further action on optimizing the firmware.</p>"},{"location":"benchmarks/#firmware-size","title":"Firmware size","text":"<p>When compiling a firmware with MicroOCPP, the resulting binary will contain functionality which is not related to OCPP, like hardware drivers, modules which are shared, like MbedTLS and the actual MicroOCPP object files. The size of the latter is the final flash requirement of MicroOCPP.</p> <p>For the flash benchmark, the profiler compiles a dummy OCPP firmware, analyzes the size of the compilation units using bloaty and evaluates the bloaty report using a Python script. To give realistic results, the firwmare is compiled with <code>-Os</code>, no RTTI or exceptions and newlib as the standard C library. The following tables show the results.</p>"},{"location":"benchmarks/#ocpp-16","title":"OCPP 1.6","text":"<p>The following table shows the cumulated size of the objects files per module. The Module category consists of the OCPP 2.0.1 functional blocks, OCPP 1.6 feature profiles and general functionality which is shared accross the library. If a feature of the implementation falls under both an OCPP 2.0.1 functional block and OCPP 1.6 feature profile definition, it is preferrably assigned to the OCPP 2.0.1 category. This allows for better comparability between both OCPP versions.</p> <p>Table 1: Firmware size per Module</p> Module Binary size (Bytes) B - Provisioning 6704 C - Authorization 640 Configuration 12384 Core 16012 D - Local Authorization List Management 7576 E - Transactions 10360 Firmware Management 11345 G - Availability 2588 General 14612 General - API 16284 General - Hardware Abstraction Layer 1468 General - RPC framework 11796 H - Reservation 3976 J - MeterValues 13776 K - SmartCharging 14952 M - Certificate Management 4452 TriggerMessage 836 Total 149761"},{"location":"benchmarks/#ocpp-201","title":"OCPP 2.0.1","text":"<p>Table 2: Firmware size per Module</p> Module Binary size (Bytes) B - Provisioning 8752 B - Provisioning - Variables 15344 C - Authorization 1356 Configuration 11556 E - Transactions 13540 F - RemoteControl 844 G - Availability 3904 General 15132 General - API 19364 General - Hardware Abstraction Layer 1468 General - RPC framework 11980 J - MeterValues 3508 M - Certificate Management 4492 Total 111240"},{"location":"benchmarks/#memory-usage","title":"Memory usage","text":"<p>MicroOCPP uses the heap memory to process incoming messages, maintain the device model and create outgoing OCPP messages. The total heap usage should remain low enough to not risk a heap depletion which would not only affect the OCPP module, but the whole controller, because heap memory is typically shared on microcontrollers. To assess the heap usage of MicroOCPP, a test suite runs a variety of simulated charger use cases and measures the maximum occupied memory. Then, the maximum observed value is considered as the memory requirement of MicroOCPP.</p> <p>Another important figure is the base level which is much closer to the average heap usage. The total heap usage consists of a base level and a dynamic part. Some memory objects are only initialized once during startup or as the device model is populated (e.g. Charging Schedules) and therefore belong to the base which changes only slowly over time. In contrast, objects for the JSON parsing and serialization and the internal execution of the operations are highly dynamic as they are instantiated for one operation and freed again after completion of the action. If the firmware contains multiple components besides MicroOCPP with this usage pattern, then the average total memory occupation of the device RAM is even closer to the base levels of the individual components.</p> <p>The following table shows the dynamic heap usage for a variety of test cases, followed by the base level and resulting maximum memory occupation of MicroOCPP. At the time being, the measurements are limited to only OCPP 2.0.1 and a narrow set of test cases. They will be gradually extended over time.</p> <p>Table 3: Memory usage per use case and total</p> Testcase Pass Heap usage (Bytes) B:Provisioning Get Variables - single value - 2380 Set Variables - multiple values - 2523 Get Base Report - FullInventory x 22287 Set Variables - Unknown component x 1899 Set Variables - Read-only - 2349 C:Authorization Local start transaction - Authorization Blocked x 2997 E:Transactions Start transaction options - PowerPathClosed x 3173 Local start transaction - Authorization first - Success - 3173 Stop transaction options - PowerPathClosed - Local stop - 3173 Stop transaction options - StopAuthorized - Local - 3173 Stop transaction options - StopAuthorized - Remote - 3173 Check Transaction status - TransactionId unknown - 1445 Check Transaction status - Transaction with id ended - with message in queue - 1445 Check Transaction status - Without transactionId - without message in queue - 1445 F:Remote Control Remote start transaction - Cable plugin first - 2997 Remote start transaction - Remote start first - Cable plugin timeout x 3277 Remote unlock Connector -  Without ongoing transaction - No cable connected - 1445 Remote unlock Connector -  Without ongoing transaction - UnknownConnector - 1445 Trigger message - TransactionEvent - Specific EVSE - 3173 Trigger message - StatusNotification - Specific EVSE - Available - 1445 Trigger message - NotImplemented - 1445 G:Availability Change Availability EVSE - Operative to inoperative x 1445 Change Availability Charging Station - Inoperative to operative x 1445 Change Availability EVSE - Operative to operative x 1445 Change Availability Charging Station - Operative to operative x 1445 Change Availability Connector - Operative to operative x 1445 J:Meter Values [Watchlist] Sampled Meter Values - EventType Started - EVSE known - 3239 [Watchlist] Sampled Meter Values - EventType Ended - 1445 Simulator stats Base memory occupation 16824 Test case maximum 22287 Total memory maximum 39111"},{"location":"benchmarks/#full-data-sets","title":"Full data sets","text":"<p>This section contains the raw data which is the basis for the evaluations above.</p> <p>Table 4: All compilation units for OCPP 1.6 firmware</p> Compile Unit Binary size (Bytes) v16 v201 Module MicroOcpp.cpp 14368 x x General - API Core/Configuration.cpp 3104 x x Configuration Core/ConfigurationContainer.cpp 864 x x Configuration Core/ConfigurationContainerFlash.cpp 4192 x x Configuration Core/ConfigurationKeyValue.cpp 708 x x Configuration Core/Connection.cpp 272 x x General - Hardware Abstraction Layer Core/Context.cpp 380 x x General Core/FilesystemAdapter.cpp 1196 x x General - Hardware Abstraction Layer Core/FilesystemUtils.cpp 4592 x x General Core/FtpMbedTLS.cpp 5140 x x General Core/Memory.cpp 156 x x General Core/Operation.cpp 104 x x General - RPC framework Core/OperationRegistry.cpp 1616 x x General - RPC framework Core/Request.cpp 3400 x x General - RPC framework Core/RequestQueue.cpp 6676 x x General - RPC framework Core/Time.cpp 2472 x x General Model/Authorization/AuthorizationData.cpp 1320 x D - Local Authorization List Management Model/Authorization/AuthorizationList.cpp 3732 x D - Local Authorization List Management Model/Authorization/AuthorizationService.cpp 1704 x D - Local Authorization List Management Model/Boot/BootService.cpp 3804 x x B - Provisioning Model/Certificates/Certificate.cpp 668 x x M - Certificate Management Model/Certificates/CertificateMbedTLS.cpp 2100 x x M - Certificate Management Model/Certificates/CertificateService.cpp 468 x x M - Certificate Management Model/Certificates/Certificate_c.cpp 0 x x M - Certificate Management Model/ConnectorBase/Connector.cpp 12240 x Core Model/ConnectorBase/ConnectorsCommon.cpp 2136 x Core Model/ConnectorBase/Notification.cpp 72 x Core Model/Diagnostics/DiagnosticsService.cpp 5825 x Firmware Management Model/FirmwareManagement/FirmwareService.cpp 4060 x Firmware Management Model/Heartbeat/HeartbeatService.cpp 420 x x G - Availability Model/Metering/MeterStore.cpp 2900 x J - MeterValues Model/Metering/MeterValue.cpp 3276 x J - MeterValues Model/Metering/MeteringConnector.cpp 4312 x J - MeterValues Model/Metering/MeteringService.cpp 1848 x J - MeterValues Model/Metering/ReadingContext.cpp 180 x J - MeterValues Model/Metering/SampledValue.cpp 780 x J - MeterValues Model/Model.cpp 1872 x x General Model/Reservation/Reservation.cpp 1072 x H - Reservation Model/Reservation/ReservationService.cpp 1384 x H - Reservation Model/Reset/ResetService.cpp 984 x x B - Provisioning Model/SmartCharging/SmartChargingModel.cpp 3804 x K - SmartCharging Model/SmartCharging/SmartChargingService.cpp 6932 x K - SmartCharging Model/Transactions/Transaction.cpp 156 x x E - Transactions Model/Transactions/TransactionDeserialize.cpp 3048 x E - Transactions Model/Transactions/TransactionStore.cpp 2372 x E - Transactions Operations/Authorize.cpp 640 x x C - Authorization Operations/BootNotification.cpp 1288 x x B - Provisioning Operations/CancelReservation.cpp 364 x H - Reservation Operations/ChangeAvailability.cpp 496 x G - Availability Operations/ChangeConfiguration.cpp 836 x Configuration Operations/ClearCache.cpp 432 x Core Operations/ClearChargingProfile.cpp 824 x K - SmartCharging Operations/CustomOperation.cpp 0 x x General - RPC framework Operations/DataTransfer.cpp 516 x Core Operations/DeleteCertificate.cpp 700 x x M - Certificate Management Operations/DiagnosticsStatusNotification.cpp 220 x Firmware Management Operations/FirmwareStatusNotification.cpp 244 x Firmware Management Operations/GetCompositeSchedule.cpp 1076 x K - SmartCharging Operations/GetConfiguration.cpp 2680 x x Configuration Operations/GetDiagnostics.cpp 640 x Firmware Management Operations/GetInstalledCertificateIds.cpp 1588 x K - SmartCharging Operations/GetLocalListVersion.cpp 268 x D - Local Authorization List Management Operations/Heartbeat.cpp 780 x x G - Availability Operations/InstallCertificate.cpp 516 x x M - Certificate Management Operations/MeterValues.cpp 660 x J - MeterValues Operations/RemoteStartTransaction.cpp 1180 x E - Transactions Operations/RemoteStopTransaction.cpp 404 x E - Transactions Operations/ReserveNow.cpp 1156 x H - Reservation Operations/Reset.cpp 628 x x B - Provisioning Operations/SendLocalList.cpp 552 x D - Local Authorization List Management Operations/SetChargingProfile.cpp 728 x K - SmartCharging Operations/StartTransaction.cpp 1352 x E - Transactions Operations/StatusNotification.cpp 892 x x G - Availability Operations/StopTransaction.cpp 1848 x E - Transactions Operations/TriggerMessage.cpp 836 x TriggerMessage Operations/UnlockConnector.cpp 616 x Core Operations/UpdateFirmware.cpp 356 x Firmware Management MicroOcpp_c.cpp 1916 x x General - API <p>Table 5: All compilation units for OCPP 2.0.1 firmware</p> Compile Unit Binary size (Bytes) v16 v201 Module MicroOcpp.cpp 17568 x x General - API Core/Configuration.cpp 3104 x x Configuration Core/ConfigurationContainer.cpp 864 x x Configuration Core/ConfigurationContainerFlash.cpp 4192 x x Configuration Core/ConfigurationKeyValue.cpp 708 x x Configuration Core/Connection.cpp 272 x x General - Hardware Abstraction Layer Core/Context.cpp 396 x x General Core/FilesystemAdapter.cpp 1196 x x General - Hardware Abstraction Layer Core/FilesystemUtils.cpp 4592 x x General Core/FtpMbedTLS.cpp 5172 x x General Core/Memory.cpp 156 x x General Core/Operation.cpp 104 x x General - RPC framework Core/OperationRegistry.cpp 1632 x x General - RPC framework Core/Request.cpp 3484 x x General - RPC framework Core/RequestQueue.cpp 6760 x x General - RPC framework Core/Time.cpp 2504 x x General Model/Authorization/AuthorizationData.cpp 1356 x D - Local Authorization List Management Model/Authorization/AuthorizationList.cpp 3760 x D - Local Authorization List Management Model/Authorization/AuthorizationService.cpp 1712 x D - Local Authorization List Management Model/Authorization/IdToken.cpp 344 x C - Authorization Model/Availability/AvailabilityService.cpp 1380 x x G - Availability Model/Boot/BootService.cpp 3872 x x B - Provisioning Model/Certificates/Certificate.cpp 668 x x M - Certificate Management Model/Certificates/CertificateMbedTLS.cpp 2104 x x M - Certificate Management Model/Certificates/CertificateService.cpp 468 x x M - Certificate Management Model/Certificates/Certificate_c.cpp 0 x x M - Certificate Management Model/ConnectorBase/Connector.cpp 12448 x Core Model/ConnectorBase/ConnectorsCommon.cpp 2448 x Core Model/ConnectorBase/Notification.cpp 72 x Core Model/Diagnostics/DiagnosticsService.cpp 5861 x Firmware Management Model/FirmwareManagement/FirmwareService.cpp 4076 x Firmware Management Model/Heartbeat/HeartbeatService.cpp 420 x x G - Availability Model/Metering/MeterStore.cpp 2924 x J - MeterValues Model/Metering/MeterValue.cpp 3300 x J - MeterValues Model/Metering/MeterValuesV201.cpp 3328 x J - MeterValues Model/Metering/MeteringConnector.cpp 4312 x J - MeterValues Model/Metering/MeteringService.cpp 1848 x J - MeterValues Model/Metering/ReadingContext.cpp 180 x J - MeterValues Model/Metering/SampledValue.cpp 780 x J - MeterValues Model/Model.cpp 2312 x x General Model/RemoteControl/RemoteControlService.cpp 844 x F - RemoteControl Model/Reservation/Reservation.cpp 1072 x H - Reservation Model/Reservation/ReservationService.cpp 1384 x H - Reservation Model/Reset/ResetService.cpp 2612 x x B - Provisioning Model/SmartCharging/SmartChargingModel.cpp 3804 x K - SmartCharging Model/SmartCharging/SmartChargingService.cpp 6932 x K - SmartCharging Model/Transactions/Transaction.cpp 1628 x x E - Transactions Model/Transactions/TransactionDeserialize.cpp 2964 x E - Transactions Model/Transactions/TransactionService.cpp 9040 x E - Transactions Model/Transactions/TransactionStore.cpp 10960 x E - Transactions Model/Variables/Variable.cpp 1800 x B - Provisioning - Variables Model/Variables/VariableContainer.cpp 2196 x B - Provisioning - Variables Model/Variables/VariableService.cpp 4420 x B - Provisioning - Variables Operations/Authorize.cpp 1012 x x C - Authorization Operations/BootNotification.cpp 1408 x x B - Provisioning Operations/CancelReservation.cpp 368 x H - Reservation Operations/ChangeAvailability.cpp 888 x G - Availability Operations/ChangeConfiguration.cpp 860 x Configuration Operations/ClearCache.cpp 440 x Core Operations/ClearChargingProfile.cpp 752 x K - SmartCharging Operations/CustomOperation.cpp 0 x x General - RPC framework Operations/DataTransfer.cpp 520 x Core Operations/DeleteCertificate.cpp 716 x x M - Certificate Management Operations/DiagnosticsStatusNotification.cpp 220 x Firmware Management Operations/FirmwareStatusNotification.cpp 244 x Firmware Management Operations/GetBaseReport.cpp 544 x B - Provisioning - Variables Operations/GetCompositeSchedule.cpp 1040 x K - SmartCharging Operations/GetConfiguration.cpp 2688 x x Configuration Operations/GetDiagnostics.cpp 652 x Firmware Management Operations/GetInstalledCertificateIds.cpp 1596 x K - SmartCharging Operations/GetLocalListVersion.cpp 268 x D - Local Authorization List Management Operations/GetVariables.cpp 2356 x B - Provisioning - Variables Operations/Heartbeat.cpp 780 x x G - Availability Operations/InstallCertificate.cpp 536 x x M - Certificate Management Operations/MeterValues.cpp 660 x J - MeterValues Operations/NotifyReport.cpp 2112 x B - Provisioning - Variables Operations/RemoteStartTransaction.cpp 1192 x E - Transactions Operations/RemoteStopTransaction.cpp 408 x E - Transactions Operations/RequestStartTransaction.cpp 536 x E - Transactions Operations/RequestStopTransaction.cpp 396 x E - Transactions Operations/ReserveNow.cpp 1160 x H - Reservation Operations/Reset.cpp 860 x x B - Provisioning Operations/SendLocalList.cpp 560 x D - Local Authorization List Management Operations/SetChargingProfile.cpp 732 x K - SmartCharging Operations/SetVariables.cpp 1916 x B - Provisioning - Variables Operations/StartTransaction.cpp 1292 x E - Transactions Operations/StatusNotification.cpp 1324 x x G - Availability Operations/StopTransaction.cpp 1848 x E - Transactions Operations/TransactionEvent.cpp 1940 x E - Transactions Operations/TriggerMessage.cpp 844 x TriggerMessage Operations/UnlockConnector.cpp 172 x Core Operations/UpdateFirmware.cpp 364 x Firmware Management MicroOcpp_c.cpp 1796 x x General - API"},{"location":"intro-tech/","title":"Technical introduction","text":"<p>This chapter covers the technical concepts of MicroOCPP.</p>"},{"location":"intro-tech/#scope-of-microocpp","title":"Scope of MicroOCPP","text":"<p>The OCPP specification defines a charger data model, operations on the data model and the resulting physical behavior on the charger side. MicroOCPP implements the full scope of OCPP, i.e. a minimalistic data store for the data model, the OCPP operations and an interface to the surrounding firmware.</p> <p>Another part of OCPP is its messaging mechanism, the so-called Remote Procedure Calls (RPC) framework. MicroOCPP also implements the specified RPC framework with the required guarantees of message delivery or the corresponding error handling.</p> <p>At the lowest layer, OCPP relies on standard WebSockets. MicroOCPP works with any WebSocket library and has a lean interface to integrate them.</p> <p>The high-level API in <code>MicroOcpp.h</code> bundles all touch points of the EVSE firmware with the OCPP library.</p> <p> Overview of the architecture </p>"},{"location":"intro-tech/#high-level-ocpp-support","title":"High-level OCPP support","text":"<p>Being a full implementation of OCPP, MicroOCPP handles the OCPP communication, i.e. it sends OCPP requests and processes incoming OCPP requests autonomously. The messages are triggered by the internal data model and by input from the high-level API. Incoming OCPP requests are used to update the internal data model and if an action on the charger is required, the library signals that to the main firmware through the high-level API.</p> <p>In consequence, the high-level API decouples the main firmware from the OCPP communication and hides the operations. This has the following good reasons:</p> <ul> <li>The high-level API guarantees correctnes of the OCPP integration. As soon as the charger adopts it properly, it is fully OCPP-compliant</li> <li>The hardware-near design decreases the integration effort into the firmware hugely</li> <li>The API won't change substantially for the OCPP 2.0.1 upgrade. The EVSE will get OCPP 2.0.1 support on the fly by a later firmware update</li> </ul>"},{"location":"intro-tech/#customizability","title":"Customizability","text":"<p>One core principle of the architecture of MicroOCPP is the customizability and the selective usage of its components.</p> <p>Selective usage of components means that the EVSE firmware can use parts of MicroOCPP and work with its own implementation for the rest. In that case only the selected parts of MicroOCPP will be compiled into the firmware. For example, the main firmware can use the RPC framework and build a custom implementation of the OCPP logic on top of it. This could be necessary if the OCPP behavior should be tightly coupled to other modules of the firmware. In a different scenario, the EVSE firmware could already contain an extensive RPC framework and the OCPP client should reuse it. Then, only the business logic and high-level API are of interest.</p> <p> Selective usage of MicroOCPP </p> <p>Customizations of the library allow to integrate use cases for which the high-level API is too restrictive. The high-level API is designed to provide a facade for the expected usage of the library, but since the charging sector is driven by innovation, new use cases for OCPP emerge every day. If a custom use case cannot be integrated on the API level, the main firmware can access the internal data structures of MicroOCPP and complement the required functionality or replace parts of the internal behavior with custom implementations which fits the concrete scenarios better.</p>"},{"location":"intro-tech/#main-loop-paradigm","title":"Main-loop paradigm","text":"<p>MicroOCPP works with the common main-loop execution model of microcontrollers. After initialization, the EVSE firmware most likely enters a main-loop and repeats it infinitely. To run MicroOCPP, a call to its loop function must be placed into the main loop of the firmware. Then at each main-loop iteration, MicroOCPP executes its internal routines, i.e. it processes input data, updates its data model, executes operations and creates new output data. The MicroOCPP loop function does not block the main loop but executes immediately. This library does not contain any delay functions. Some activities of the library spread over many loop iterations like the start of a charging session which needs to await the approval of an NFC card and a hardware diagnosis of the high power electronics for example. All activities in MicroOCPP support the distribution over many loop calls, leading to a pseudo-parallel execution behavior.</p> <p>No separate RTOS task is needed and MicroOCPP does not have an internal mechanism for multi-task synchronization. However, it is of course possible to create a dedicated OCPP task, as long as extra care is taken of the synchronization.</p>"},{"location":"intro-tech/#how-the-api-works","title":"How the API works","text":"<p>The high-level API consists of four parts:</p> <ul> <li>Library lifecycle: The library has initialize functions with a few initialization options. Dynamic system components like the WebSocket adapter need to be set at initialization time. The deinitialize function reverts the library into an unitialized state. That's useful for memory inspection tools like valgrind or to disable the OCPP communication. The loop function also counts as part of the lifecycle management.</li> <li>Sensor Inputs: EVSEs are mechanical systems with a variety of sensor information. OCPP is used to send parts of the sensor readings to the server. The other part of the sensor data flows into the local charger model of MicroOCPP where it is further processed. To update MicroOCPP with the input data from the sensors, the firmware needs to bind the sensors to the library. An Input-binding, or in short Input, is a function which transfers the current sensor value to MicroOCPP. Inputs are callback functions which read a specific sensor value and pass the value in the return statement. The firmware defines those callback functions for each sensor and adds them to MicroOCPP during initialization. After initialization, MicroOCPP uses the callbacks and executes them to fetch the most recent sensor values.  This concept is reused for the data Outputs of the library to the firmware, where the callback applies output data from MicroOCPP to the firmware.</li> <li>Transaction management: OCPP considers EVSEs as vending machines. To enable payment processing and the billing of the EVSE usage, all charging activity is assigned to transactions. A big portion of OCPP is about transactions, their prerequisites, runtime and their termination scenarios. The MicroOCPP API breaks transactions down into an initiation and termination function and gives a transparent view on the current process status, authorization result and offline behavior strategy. For non-commercial setups, the transaction mechanism is the same but has only informational purposes.</li> <li>Device management: MicroOCPP implements the OCPP side of the device management operations. For the actual execution, the firmware needs to provide the charger-side implementations of the operations to MicroOCPP by passing handler functions to the API. For example, the OCPP server can restart the charger. Upon receipt of the request, MicroOCPP terminates the transactions and eventually triggers the system restart using the handler function which the firmware has provided through the high-level API.</li> </ul>"},{"location":"intro-tech/#transaction-safety","title":"Transaction safety","text":"<p>Software in EVSEs needs to withstand hazardous operating conditions. EVSEs are located on the street or in garages where the WiFi or LTE signal strength is often weak, leading to long offline periods or where random power cuts can occur. In addition to that, the lack of process virtualization on microcontrollers means that a malfunction in one part of the firmware leads to the crash of all other parts.</p> <p>The transaction process of MicroOCPP is robust against random failures or resets. A minimal transaction log on the flash storage ensures that each operation on a transaction is fully executed. It will always result in a consistent state between the EVSE and the OCPP server, even over resets of the microcontroller. The RPC queue facilitates this by tracking the delivery status of relevant messages. If the microcontroller is reset while the delivery status of a message is unknown, MicroOCPP takes up the message delivery again at the next start up and completes it.</p> <p>A requirement for the transaction safety feature is the availability of a journaling file system. Examples include LittleFS, SPIFFS and the POSIX file API, but some microcontroller platforms don't support this natively, so an extension would be required.</p>"},{"location":"intro-tech/#unit-testing","title":"Unit testing","text":"<p>MicroOCPP includes a number of unit tests based on the Catch2 framework. A GitHub Action runs the unit tests against each new commit in the MicroOCPP repository, which ensures that new features don't break old code.</p> <p>The scope of the unit tests is to to ensure a correct implementation of OCPP and to validate the high-level API against its definition. For that, it is not necessary to establish an actual test connection to an OCPP server. In fact, real-world communication would disturb the tests and make them undeterministic. That's why the test suite is fully based on an integrated, tiny OCPP test server which the OCPP client reaches over a loopback connection. The test suite does not access the WebSocket library. When making the unit tests of the main firmware, it is not necessary to check the full OCPP communication, but only to validate correct usage of the high-level API. An example of how the library can be initialized with a loopback connection can be found in its test suite.</p>"},{"location":"intro-tech/#microcontroller-optimization","title":"Microcontroller optimization","text":"<p>As a library for microcontrollers, the design of MicroOCPP considers the strict memory limits and complies with the best practices of embedded software development. Also, a few measures were taken to optimize the memory usage which include the spare inclusion of external libraries, an optimization of the internal data structures and the exclusion of C++ run-time type information (RTTI) and exceptions. Features of C++ which may have a larger footprint are carefully used such as the standard template library (STL) and lambda functions. The STL increases the robustness of the code and lambdas prove to be a powerful tool to deal with the complexity of asynchronous data processing in embedded systems. That's also why the high-level API has many functional parameters.</p> <p>Because of the high importance of C in the embedded world, MicroOCPP provides its high-level API in C too. It is typically simple to instruct the compiler to compile and link the C++-based library in a C-based firmware development. In case that the firmware requires custom features which are not part of the C-API, then the firmware can implement it in a new C++ source file, export the new functions to the C namespace and use it normally in the main source.</p> <p>While memory constraints are of concern, the execution time generally is not. OCPP is rather uncomplex on the algorithmic side for clients, since there is no need for elaborate planning algorithms or complex data transformations.</p> <p>Low resource requirements also allow new usage areas on top of EV charging. For example, MicroOCPP has been ported to ordinary IoT equipment such as Wi-Fi sockets to integrate further electric devices into OCPP networks.</p> <p>Although MicroOCPP is optimized for the usage on microcontrollers, it is also suitable for embedded Linux systems. With more memory available, the upper limits of the internal data structures can be increased, leading to a more versatile support of charging use cases. Also, the separation of the charger firmware into multiple processes can lead to more robustness. MicroOCPP can be extended by an inter-process communication (IPC) interface to run in a separate process.</p>"},{"location":"migration/","title":"Migrating to v1.1","text":"<p>As a new minor version, all features should work the same as in v1.0 and existing integrations are mostly backwards compatible. However, some fixes / cleanup steps in MicroOCPP require syntactic changes or special consideration when upgrading from v1.0 to v1.1. The known pitfalls are as follows:</p> <ul> <li>The default branch has been renamed from <code>master</code> into <code>main</code></li> <li>Need to include extra headers: the transitive includes have been cleaned a bit. Probably it's necessary to add more includes next to <code>#include &lt;MicroOcpp.h&gt;</code>. E.g.<code>#include &lt;MicroOcpp/Model/Diagnostics/DiagnosticsService.h&gt;</code><code>#include &lt;MicroOcpp/Model/FirmwareManagement/FirmwareService.h&gt;</code></li> <li><code>ocppPermitsCharge()</code> does not consider failures reported by the charger anymore. Before v1.1 it was possible to report failures to MicroOCPP using ErrorCodeInputs and then to rely on <code>ocppPermitsCharge()</code> becoming false when a failure occurs. For backwards compatibility, complement any occurence to <code>ocppPermitsCharge() &amp;&amp; !isFaulted()</code></li> <li><code>setEnergyMeterInput</code> changed the expected return type of the callback function from <code>float</code> to <code>int</code> (see #301)</li> <li>The return type of the UnlockConnector handler also changed from <code>PollResult&lt;bool&gt;</code> to enum <code>UnlockConnectorResult</code> (see #271)</li> </ul> <p>If upgrading MicroOcppMongoose at the same time, then the following changes are very important to consider:</p> <ul> <li>Certificates are no longer copied into heap memory, but the MO-Mongoose class takes the passed certificate pointer as a zero-copy parameter. The string behind the passed pointer must outlive the MO-Mongoose class (see #10)</li> <li>WebSocket authorization keys are no longer stored as c-strings, but as <code>unsigned char</code> buffers. For backwards compatibility, a null-byte is still appended and the buffer can be accessed as c-string, but this should be tested in existing deployments. Furtermore, MicroOCPP only accepts hex-encoded keys coming via ChangeConfiguration which is mandated by the standard. This also may break existing deployments (see #4).</li> </ul> <p>If accessing the MicroOCPP modules directly (i.e. not over <code>MicroOcpp.h</code> or <code>MicroOcpp_c.h</code>) then there are likely some more modifications to be done. See the history of pull requests where each change to the code is documented. However, if the existing integration compiles under the new MO version, then there shouldn't be too many unexpected incompatibilities.</p>"},{"location":"migration/#migrating-to-v10","title":"Migrating to v1.0","text":"<p>The API has been continously improved to best suit the common use cases for MicroOCPP. Moreover, the project has been given a new name to prevent confusion with the relation to the Arduino platform and to reflect the project goals properly. With the new project name, the API has been frozen for the v1.0 release.</p>"},{"location":"migration/#adopting-the-new-project-name-in-existing-projects","title":"Adopting the new project name in existing projects","text":"<p>Find and replace the keywords in the following.</p> <p>If using the C-facade (skip if you don't use anything from ArduinoOcpp_c.h):</p> <ul> <li><code>AO_Connection</code> to <code>OCPP_Connection</code></li> <li><code>AO_Transaction</code> to <code>OCPP_Transaction</code></li> <li><code>AO_FilesystemOpt</code> to <code>OCPP_FilesystemOpt</code></li> <li><code>AO_TxNotification</code> to <code>OCPP_TxNotification</code></li> <li><code>ao_set_console_out_c</code> to <code>ocpp_set_console_out_c</code></li> </ul> <p>Change this in any case:</p> <ul> <li><code>ArduinoOcpp</code> to <code>MicroOcpp</code></li> <li><code>\"AO_</code> to <code>\"Cst_</code> (define build flag <code>MO_CONFIG_EXT_PREFIX=\"AO_\"</code> to keep old config keys)</li> <li><code>AO_</code> to <code>MO_</code></li> <li><code>ocpp_</code> to <code>mocpp_</code></li> </ul> <p>Change this if used anywhere:</p> <ul> <li><code>ao_set_console_out</code> to <code>mocpp_set_console_out</code></li> <li><code>ao_tick_ms</code> to <code>mocpp_tick_ms</code></li> </ul> <p>If using the C-facade, change this as the final step:</p> <ul> <li><code>ao_</code> to <code>ocpp_</code></li> </ul>"},{"location":"migration/#further-api-changes-to-consider","title":"Further API changes to consider","text":"<p>In addition to the new project name, the API has also been reworked for more consistency. After renaming the existing project as described above, also take a look at the changelogs (see Section Changed for v1.0.0).</p> <p>If something is missing in this guide, please share the issue here: https://github.com/matth-x/MicroOcpp/issues/176</p>"},{"location":"modules/","title":"Modules","text":"<p>This chapter gives an overview of the class structure of MicroOCPP.</p>"},{"location":"modules/#context","title":"Context","text":"<p>The Context contains all runtime data of MicroOCPP. Every data object which this library creates is stored in the Context instance, except only the Configuration. So it is the basic entry point to the internals of the library. The structure of the context follows the main architecture as described in this introduction and consists of the Request queue and message deserializer for the RPC framework and the Model object for the OCPP model and behavior (see below).</p> <p>When the library is initialized, <code>getOcppContext()</code> returns the current Context object.</p>"},{"location":"modules/#model","title":"Model","text":"<p>The Model represents the OCPP device model and behavior. OCPP defines a rough charger model, i.e. the hardware parts of the charger and their basic functionality in relation to the OCPP operations. Furthermore, OCPP specifies a few only software related features like the reservation of the charger. This charger model is implemented as straightforward C++ data structures and corresponding algorithms.</p> <p>The implementation of the Model is structured into a top-level Model class and the subordinate Service classes. Each Service class represents a functional block of the OCPP specification and implements the corresponding data structures and functionality. The definition of the functional blocks in MicroOCPP is very similar to the feature profiles in OCPP. Only the Core profile is split into multiple functional blocks to keep a smaller module scope.</p> <p>The following list contains the resulting functional blocks:</p> <ul> <li>Authorization: local information of user identifiers and their authorization status</li> <li>Boot: implementation of the preboot behavior, i.e. sending and processing the BootNotification message</li> <li>ChargingSession: management of charging sessions and control of the high power charging hardware</li> <li>Diagnostics: GetDiagnostics upload routine</li> <li>FirmwareManagement: UpdateFirmware download routine</li> <li>Heartbeat: periodic OCPP Heartbeats (not including WebSocket ping-pongs)</li> <li>Metering: periodic MeterValue messages and local caching</li> <li>Reservation: management of Reservation lists and their effect on the authorization routine</li> <li>Reset: execution of OCPP Reset message</li> <li>Transactions: transaction journal behind StartTransaction and StopTransaction messages and Transaction class for extensions of the transaction mechanism</li> </ul>"},{"location":"modules/#requests","title":"Requests","text":"<p>The Request class and all similarly named classes implement the Remote Procdure Call (RPC) framework of OCPP. A request executes an operation on the remote end of an OCPP connection. If a charger sends a request to a server, then the server will update its data base with the payload and vice versa. After receiving a request, each node replies with a confirmation, acknowledging the successful execution of the operation or notifying about an error.</p> <p>When being offline, outgoing requests must be queued before sending which is implemented in RequestQueue. Queueing is especially challenging for longer offline periods when the number of cached messages exceeds the memory limit. To address this, messages are swapped to the flash memory when the queue limit is reached as implemented in the RequestStore and RequestQueueStorageStrategy class. Incoming messages can be processed directly and don't have an extensive queueing mechanism.</p>"},{"location":"modules/#operations","title":"Operations","text":"<p>Every OCPP operation (e.g. Heartbeat, BootNotification) has a dedicated class for creating outgoing messages, interpreting incoming messages, executing the specified OCPP action and handling responses. Operations work on the data structures of the Model layer.</p> <p>To send operations to the OCPP server, they must be wrapped into a Request object. The RPC framework and operations are separated modules. While the RPC framework (including the Request class) deals with the messaging mechanism and transfering data to the other OCPP device, operations define the effect on the OCPP model and data structure and execute the desired action. The operation classes inherit from Operation which is the interface visible to the Request class.</p> <p>Incoming messages are unmarshalled using the OperationRegistry. During the initialization phase of the library, the Model classes register all supported operations with their name and an instantiator. The instantiator, when executed, provides the Request interpreter with an instance of the corresponding Operation subclasses. It is possible to extend MicroOCPP by adding new Operation instantiators to the registry, or to modify the behavior by overriding the default Operation implementations. In addition to that, event handlers can be set which the RPC queue will notify with the payload once operations are sent or received.</p>"},{"location":"modules/#configuration","title":"Configuration","text":"<p>Configurations like the HeartbeatInterval are managed by the Configuration module which consists of</p> <ul> <li>AbstractConfiguration: a single configuration as a key-value pair without value type<ul> <li>Configuration: a concrete configuration with a value type like <code>bool</code> or <code>const char*</code>. Inherits from AbstractConfiguration</li> </ul> </li> <li>ConfigurationContainer: a collection of AbstractConfigurations and an optional storage implementation. Multiple containers can be set for a separation of the configurations and different storage strategies. Each container has a unique file name<ul> <li>ConfigurationContainerVolatile: no persistency and access to the file system</li> <li>ConfigurationContainerFlash: persistency by storing JSON files on the flash</li> </ul> </li> </ul> <p>If another storage implementation is required (e.g. for syncing with an external configuration manager), then it's possible to add a custom ConfigurationContainer.</p> <p>In the initialization phase, MicroOCPP loads the built-in Configurations with hard-coded factory defaults and a default storage structure. To customize the factory defaults or which ConfigurationContainers will be used, the Configuration module must be initialized before loading the library. To do so, call <code>configuration_init(...)</code>. Then the factory defaults can be applied by calling <code>declareConfiguration&lt;T&gt;(...)</code> with the desired default value. To use a custom ConfigurationContainer, call <code>addConfigurationContainer(...)</code> with the custom implementation. When the library is loaded afterwards, it will use the previously provided Configurations / Containers and create only the data structure which hasn't been set already.</p>"},{"location":"prerequisites/","title":"Development tools and basic prerequisites","text":"<p>This page explains how to work with this library using the appropriate development tools. Skip it if your IDE is set up and you already have an OCPP test server.</p>"},{"location":"prerequisites/#development-tools-prerequisites","title":"Development tools prerequisites","text":"<p>Throughout these document pages, it is assumed that you already have set up your development environment and that you are familiar with the corresponding building, flashing and (basic) debugging routines. MicroOCPP runs in many environments (from the Arduino-IDE to proprietary microcontroller IDEs like the Code Composer Studio). If you do not have any preferences yet, it is highly recommended to get started with VSCode + the PlatformIO add-on, since it is the favorite setup of the community and therefore you find the most related information in the Issues pages of the main repository.</p> <p>There are many high-quality tutorials for out there for setting up VSCode + PIO. The following site covers everything you need to know: https://randomnerdtutorials.com/vs-code-platformio-ide-esp32-esp8266-arduino/</p> <p>Once that's done, adding MicroOCPP is no big deal anymore. However, let's discuss another very important tool for your project first.</p>"},{"location":"prerequisites/#ocpp-server-prerequisites","title":"OCPP Server prerequisites","text":"<p>MicroOCPP is just a client, but all the magic of OCPP lives in the communication between a client and a server. Although it is possible to run MicroOCPP without a real server for testing purposes, the best approach for getting started is to get the hands on a real server. So you can always use the client in a practical setup, see immediate results and simplify development a lot.</p> <p>Perhaps you were already given access to an OCPP server for your project. Then you can use that, it should work fine. If you don't have a server already, it is highly recommended to get SteVe (https://github.com/steve-community/steve). It allows to control every detail of the OCPP operations and shows detail-rich information about the results. And again, it is the favorite test server of the community, so you will find the most related information on the Web. For the installation instructions, please refer to the SteVe docs.</p> <p>In case you can't wait to get started, you can make the first connection test with a WebSocket echo server as a fake OCPP service. MicroOCPP supports that: it can send all messages to an echo server which reflects all traffic. MicroOCPP gets back its own messages and replies to itself with mocked responses. Complicated, but it does work and the console will show a valid OCPP communication. An example echo server is given in the following section. For the further development though, you will definitely need a real OCPP server.</p>"},{"location":"prerequisites/#project-structure","title":"Project structure","text":"<p>MicroOCPP is a library, i.e. it is not a full firmware, but just solves one specific task in your project which is the OCPP connectivity. The project structure should reflect this: typically you download MicroOCPP into a libraries or dependencies subfolder, while the main part of the development takes place in a main source folder. All dependencies of MicroOCPP (i.e. ArduinoJson, see the dependencies sections) should be located in the same libraries or dependencies folder.</p> <p>When the include paths are correctly set up, you should be able <code>#include &lt;MicroOcpp.h&gt;</code> at the top of your own source files. This setup keeps the OCPP library source separate from your integration and gives the project a clear structure.</p>"},{"location":"prerequisites/#dependency-managers","title":"Dependency managers","text":"<p>Currently, the PlatformIO dependency manager is supported. In the <code>platformio.ini</code> manifest, you can add <code>matth-x/MicroOcpp</code> to the <code>lib_deps</code> section.</p>"},{"location":"security/","title":"Security","text":"<p>MicroOCPP is designed to be compatible with IoT devices which leads to special considerations regarding cyber security. This section describes the challenges and security concepts of MicroOCPP.</p>"},{"location":"security/#challenges-of-using-microcontrollers-in-safety-critical-environments","title":"Challenges of using microcontrollers in safety-critical environments","text":"<p>The two challenges are as follows:</p> <ol> <li>Lack of process virtualization in RTOS operating systems</li> <li>Less attention for potential vulnerabilities in the used libraries</li> </ol> <p>In a general purpose OS like Linux, the internet communication modules of an application typically run in a different process than the data base or the hardware supervision / control function. In contrast, on a typical RTOS, all modules are compiled into the same binary, sharing the same address space and lifecycle when being executed. This means that once the network stack crashes, all software on the chip is reset and a vulnerability on the network stack could be exploited to read or manipulate the data of the full runtime environment.</p> <p>Challenge 2) is due to the fact that OCPP uses standard web technology (WebSocket over TLS), but microcontrollers are missing out the most widespread networking software like OpenSSL or the networking libraries of Linux. The available networking libraries for microcontrollers are also audited well (e.g. lwIP, mbedTLS), but in general there is more attention on potential vulnerabilites in the Linux world, because a huge share of commercial IT systems is based on Linux.</p> <p>On the upside, an advantage of microcontrollers is their single purpose usage and thus, reduced complexity. Many security breaches are caused by misconfigured and often even superflous software components (e.g. due to overlooked open ports) which are not a regular part of a microcontroller firmware.</p>"},{"location":"security/#security-measures-of-microocpp","title":"Security measures of MicroOCPP","text":"<p>To address the challenges, the following measures were taken:</p> <ul> <li>Input sanitazion: MicroOCPP only accepts the JSON format for all input. It is validated by ArduinoJson. Every JSON value is checked against the expected format and for conformity with the OCPP specification before using it. The JSON object is discarded immediately after interpretation</li> <li>Transaction safety: to address crashes and random reboots of the microcontroller during operation, all activities of the OCPP library are programmed so that they will either be resumed or fully reverted after reboots, preventing inconsistent states. See also Transaction safety</li> <li>Careful choice of the dependencies: the mandatory dependency, ArduinoJson, has a test coverage of nearly 100% and is fuzzed. The same goes for the recommended WebSocket library, Mongoose. Both projects are very relevant in their field with over 6k and 9k stars on GitHub</li> </ul> <p>Two further measures would be beneficial and could be requested via support request:</p> <ul> <li>Precautious memory allocation: migrating memory management to the stack and where possible would simplify code analysis and reduce the potential of vulnerabilities</li> <li>OCPP fuzzer: as a stateful application protocol, there are specific challenges of developing a fuzzer. An open source fuzzing framework for OCPP could reveal vulnerabilities and be of use for other OCPP projects as well. MicroOCPP is a good foundation for trying new fuzzing approaches. The exposure of the main-loop function and the clock allow a fine-grained access to the program flow and facilitating random alterations of the environment conditions. Furthermore, all persistent data is stored in the JSON format and it is possible to develop a grammatic which contains both a device status and incoming OCPP messages. The Configuration interface could be reused for further status variables which don't need to be persistent in practice, but would improve fuzzing performance when being accessible by the fuzzer.</li> <li>Memory pool: object orientation is a very helpful programming paradigm for OCPP. The standard contains a lot of polymorphic entities and optional or variable length data fields. MicroOCPP makes use of the heap and allocates new chunks of memory as the device model is populated with data. On the upside this allows to save a lot of memory during normal operation, but it also entails the risk of memory depletion of the whole controller. A fixed memory pool for OCPP would encapsulate the heap usage to a certain address space and set a hard limit for the memory consumption and avoid polluting the shared heap area by heap fragmentation. To realize the memory pool, it would be necessary to make the allocate and deallocate functions configurable by the client code. Then appropriate (de)allocators can be injected limiting the memory use to a restricted address area. As a consequence, a more thorough allocation error handling in the MicroOCPP code is required and test cases which randomly suppress allocations to test if the library always reverts to a consistent state. A less invasive alternative to memory pools is to inject measured (de)allocators which just prevent the allocation of new memory chunks after a certain threshold has been exceeded. This programming technique would also allow to create much more fine-grained benchmarks of the library.</li> </ul>"},{"location":"security/#measures-to-be-taken-by-the-evse-vendor","title":"Measures to be taken by the EVSE vendor","text":"<p>As a general rule, the communication controller which is exposed to the internet shouldn't be used for safety-critical tasks on the charging hardware. That's because the networking stack is a very complex piece of software which very likely still has open bugs which can crash the controller despite all the effort to improve it. Safety-critical tasks on the charging hardware shouldn't rely on a controller which could crash at any time because of incoming network traffic. To mitigate this, either the OCPP library and internet functionality should be placed onto a separate chip, or the most vital safety functionality should get a dedicated controller.</p> <p>The recommended Mongoose WebSocket adapter for MicroOCPP supports the OCPP Security Profile 2 (TLS with Basic Authentication) and needs to be provided with the necessary TLS certificate.</p> <p>Most IoT-controllers have built-in mechanisms to ensure the authenticity of their firmware. For example, the Espressif32 supports Secure Boot which is a signature verification of the installed firmware before that firmware is executed. Many platforms also have a built-in signature verification for incoming OTA firmware updates. To prove the authenticity of the charger to the OCPP server, it is also important to keep the WebSocket key secret by encrypting the flash memory. These security mechanisms heavily depend on the host controller which runs MicroOCPP. It is the responsibility of the main firmware to make proper use of them.</p>"},{"location":"security/#ocpp-security-whitepaper-and-iso-15118","title":"OCPP Security Whitepaper and ISO 15118","text":"<p>With MicroOCPP, the recommended way of handling certificates on microcontrollers is to compile them into the firmware binary and to rely on the built-in firmware signature checks of the host microcontroller platform. This lean approach results in a smaller attack vector compared to establishing a separate infrastructure for the server- and firmware certificate. It can be assumed that the OTA functionality of the microcontrollers is thoroughly tested and consequently, reaching a comparable level of robustness would require much effort.</p> <p>In case the certificate handling mechanism of the Security Whitepaper is preferred, then the EVSE vendor needs to implement it via a custom extension. Unfortunately, this mechanism hasn't been requested yet and is not natively supported by MicroOCPP yet. The new custom operations can be implemented by extending the class <code>Operation</code>. A handler for incoming messages can be registered via <code>OperationRegistry::registerOperation(...)</code>. To send custom messages to the server, use <code>Context::initiateRequest(...)</code>.</p> <p>A further challenge for microcontrollers is the relatively low processor speed which becomes relevant for a potential ISO 15118 integration. Some incoming message types (<code>AuthorizationReq</code> and <code>MeteringReceiptReq</code>) include a signature which needs to be verified on the communications controller of the EVSE. Moreover, messages in the ISO 15118 V2G protocol have a maximum round trip time (which is 2 seconds for the message types in question) and so the signature verification is time-contrained. These benchmarks for the Espressif32 show that for some signature algorithms, the verification time can get close or exceed the timing requirements of ISO 15118 if done on the processor only. As a consequence, hardware acceleration by the crypto-core is mandatory to ensure a robust communication between the EVSE and EV. Before making a communications controller with ISO 15118 support, the performance of the host controller should be benchmarked and checked against the requirements.</p> <p>Disclaimer: the outlined risks in this section are not a complete list. Also, every system has unique security challenges which require individual attention. In doubt, please consult an IT-security specialist.</p>"}]}